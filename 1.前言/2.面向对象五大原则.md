> 设计模式是关于代码设计的几种招式，而面向对象五大原则是招式的本源(指导思想)， 换句话来说现有的这些设计模式都是前人依据面向对象的五大原则总结归纳出的一些套路和模板。
>
> 在这也分享一句话：剑的三层境界：一是手中有剑，心中亦有剑；二是手中无剑，心中有剑；三是手中无剑，心中亦无剑 --- [引自yaf(一个php框架)](https://www.laruence.com/manual/yaf.infos.html)
>
> 现在算是有一些的感悟了，学习设计模式之前，可能对于代码的设计上怕是第一层境界也不到，没有基本的知识储备，就算是想优化代码，写出高质量可扩展的优雅代码也有种有心无力的感觉，  算是 手中无剑，心中亦无剑。 慢慢学习了设计模式之后，感觉之前一些困扰的问题也有了解法，某些场景正好能用哪个设计模式来做，提升代码的优雅性。现在有种 手中有剑，心中亦有剑，  现在一些问题一些场景 自己有招式能去解决，  而第二境界则是，在没有场景/问题暴露之前，就可以提前运用一些招式进行预防。而第三境界则是忘记招式，回归本源，不刻意去运用招式，而是和自己融入贯通，每个代码中都包含本源的思想。
>
> 所以，在学习设计模式时候，先了解掌握面向对象的五大原则更为重要，体会到他的思想了，在后面学习设计模式的时候，慢慢体会五大原则在设计模式中启的作用，会让你理解掌握的更扎实。五大原则理解不难，但想要实际融会贯通的使用，而不是生搬硬套，也不是那么简单的，“道理我都懂，但是就是做不到”

下面会讲解五大原则（SOLID）外加一个迪米特法则, 从联系上说，不光是考虑到类的设计，而且模块之间也同样适用，不要只局限于类的层面中。

- 单一职责 (SRP)

  > 一个类只负责一个单一的功能
  >
- 开闭原则(OCP)

  > 一个类对扩展开放，对修改关闭
  >
- 接口隔离(ISP)

  > 多个专用的接口比单一的大接口好
  >
- 里氏替换(LSP)

  > 子类可以替换基类
  >
- 依赖倒转(DIP)

  > 依赖抽象/上层， 而不依赖具体/下层方法
  >
- (附)迪米特法则

  > 一个类对于其他类知道的越少越好，就是说一个对象应当对其他对象有尽可能少的了解,只和朋友通信，不和陌生人说话
  >

## 单一职责

### 如何理解单一职责

> 一个类或一个模块只负责完成一个职责或者功能。不要设计通用的大类，而是粒度更小，功能单一的类/模块。 单一职责为了实现代码的高内聚，低耦合，提高代码的复用性，可维护性，可读性。

### 如何判断类的职责是否足够单一

> 需要结合具体业务场景，不同的场景下，相同的代码判断是否是符合单一职责的答案是不同的。
> 有几个通用的规范/经验可以指导是否符合单一职责(大部分场景)
>
> - 类代码的行数、函数、熟悉多而杂， 比如单个函数超过200行， 单个类超过1000行(不是定值)
> - 类需要依赖其他类过多，耦合性较高
> - 私有方法过多
> - 类的名字比较难起(因为涉及了不同的功能，单一模块名称无法描述)
> - 类中大量的方法都是几种操作类中的某几个属性

### 类的职责是否设计的越单一越好

> 单一职责是避免设计大而全的类，避免将不相干的功能耦合在一起，来提高内聚性。同时，职责单一依赖的其他类也会变少，降低耦合性。 但是如果过于细又会出现"副作用", 类太多，类似模块之间的共性修改，需要将每个类都更新， 降低了代码可维护性。

## 开闭原则

> 对类的修改是关闭的，扩展是开放的。

### 如何理解“对扩展开放、修改关闭”

添加一个新功能，应该是在已有代码的基础上扩展代码(新增模块、类、方法、属性等)，而非修改已有代码的方式来完成。但需要注意两点：

    1. 开闭原则不能完全杜绝修改、而是以最小的修改代码的代价来完成新功能的开发
 	2. 同样代码的改动，在粗粒度下，可能被认定为“修改”，细粒度下被认定为“扩展”

### 如何做到“对扩展开放、修改关闭”

首先自身意识上我们要时刻考虑代码的扩展、抽象、封装意识。花些时间考虑业务代码未来的改动预判，留好扩展点。

很多设计原则、设计思想、设计模式都是围绕提高代码的扩展性为目的的设计的（策略、模板）

**对拓展开放是为了应对变化(需求)，对修改关闭是为了保证已有代码的稳定性；最终结果是为了让系统更有弹性！**

## 接口隔离

> 客户端不应该依赖他不需要的接口

#### 如何理解“接口隔离原则”

从两个角度来分析

- 一组API接口集合
- 单个API接口或函数

##### 一组API接口集合

比如页面关于用户的接口，现在有注册、查询、登录功能，现在后台需要一个删除用户的功能，那么这时直接加到注册、查询、登录的类中，页面中依赖了他不需要的功能(删除用户)，而且这种操作也是非常危险的，所以我们应该将两个隔离开来。

##### 单个API接口或函数

一个方法中存在多个调用方，他们调用的参数各不相同。此时这个方法包含了两个调用方的逻辑，有些参数是调用方A需要的，又有些参数是调用方B需要的，则调用方A、B必须被迫依赖他们不需要的参数，这便违反了接口隔离的原则，我们可以将方法都拆出来，各自调用方再实现一个方法进行分布组装调用各自的方法。这也有点单一职责的意思，下面也会总结下他们之间的联系和区别。

#### 接口隔离和单一职责的区别

接口隔离更偏向客户端/调用方，单一职责更偏向服务端实现的规范。违反单一职责，但有可能遵守接口隔离；但违反接口隔离原则，而遵守单一职责的场景不太好找，也就说明单一职责的严格性比隔扣隔离的要高。

## 里氏替换

> 子类对象能够替换程序中父类对象出现的任何地方，并且保证原逻辑和结构不被破坏

里氏替换可以对照多态进行比较，可以通过多态遵守里氏替换的原则，但里氏替换相比较里氏替换原则额外多了子类不能破坏父类的输入、输出、异常处理等逻辑，可以说更严格些。好处是避免了同一功能名称具有**二义性**

## 依赖倒转

> 高层模块不依赖低层模块，抽象/接口不依赖具体实现，具体实现依赖抽象。

举个例子，假设你正在编写一个用于访问数据库的模块，而低层模块使用Mysql作为数据库，那么你可以使用依赖倒转原则，将Mysql抽象成一个接口，而高层模块只需要依赖这个接口，而不需要关心具体的实现。


以上面向对象五大原则即使如此，简单进行梳理

- 单一原则概念简单，但需要根据具体业务场景进行考虑，同一种代码在不同的角度下是否符合 单一职责 答案是不一样的
- 开闭原则概念简单，但实际使用比较困难。需要根据具体业务场景进行考虑，但需要把握度，不能过度设计，大多的设计模式都是为解决/遵守开闭原则总结的。
- 接口隔离，接口/方法的调用方不应该依赖他不需要的参数/方法，"尽可能的少知道些"
- 里氏替换,  父类出现的地方，继承的子类都应该可以完美(入参、出参一致，逻辑一致)替换，避免统一方法具有二义性
- 依赖倒转， 高层不依赖低层， 抽象不依赖具体实现。如高层操作数据库类，低层mysql,  低层应该依赖高层。

#### 寄语

初次或者没有真正的多次实践思考，这几个原则理解或者完全掌握是比较难的，闲了翻看多巩固，实践时这几个原则记心中，作为自己代码的指导。可能每过段时间，对于这几个原则都会有不一样的认识，不断实践总结，凝练出自己对这个五个原则的总结和认识，这便算是真正掌握了。
