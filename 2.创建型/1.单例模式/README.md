> 在程序运行的期间，期望**某个类/配置文件/驱动**只需要初始化一次, 其他方法调用该类方法/属性都通过这一个实例，而不是重复创建/销毁,  为达到这个目的做的设计，成为单例模式



### 解决问题

1. 资源访问冲突（log文件写入覆盖,需要加互斥锁, 但如果不是同一个对象，每个调用都有各自的锁，不会互相互斥，所以单例就可以解决这种问题）
2. 配置文件(加载到内存后，应当只有一份)

### 如何实现

- 构造方法设置private，避免外部通过new创建实例
- 创建时线程安全
- 是否可以延迟加载
- 考虑getInstance()性能是否高

### 分类

> 单例模式分为两种实现：懒汉式、饿汉式   顾名思义懒汉式是**只有用到**这个配置文件/某个单例类/驱动时，**才创建**实例; 而饿汉式是在程序**刚启动时便已经创建**了实例，**不管是否会有方法来使用**
>
>  懒汉式是被动的，饿汉式是主动的。

#### 懒汉式

> 优点：懒加载，节省未使用的单例的内存开销
>
> 缺点：1. 首次使用速度慢  2.如果有问题(如oom 问题延后)

#### 饿汉式

> 优点：1. 如果有问题，将会放在程序启动时就暴露出来 2. 首次/非首次访问速度一样
>
> 缺点：1. 首次启动时慢

#### 双重检测

#### 静态内部类

#### 枚举







